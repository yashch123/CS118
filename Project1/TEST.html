<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Homework 1. Fixpoints and grammar filters</title>
<link rel="copyright" href="http://web.cs.ucla.edu/classes/winter18/cs131/copyright.html">
<link rev="made" href="mailto:eggert@cs.ucla.edu">
</head>

<body>

<h1>Homework 1. Fixpoints and grammar filters</h1>

<p><small>[<a href="http://web.cs.ucla.edu/classes/winter18/cs131/index.html">131 home</a> &gt; <a href="http://web.cs.ucla.edu/classes/winter18/cs131/homework.html">Homework</a>]</small></p>

<h2>Introduction</h2>

<p>You are a reader for Computer Science 181, which asks students to
submit grammars that solve various problems. However, many of the
submitted grammars are trivially wrong, in several ways. Here is
one. Some grammars contain blind-alley rules, that is, grammar
rules for which it is impossible to derive a string of terminal
symbols. Blind-alley rules
do not affect the language or parse trees generated by a
grammar, so in some sense they don't make the answers wrong, but
they're noise and they make grading harder. You'd like to filter out
the noise, and just grade the useful parts of each grammar.</p>

<p>You've heard that OCaml is a good language for writing compilers
and whatnot, so you decide to give it a try for this
application. While you're at it, you have a background
in <a href="https://en.wikipedia.org/wiki/Fixed_point_%28mathematics%29">fixed
point</a> and
<a href="https://en.wikipedia.org/wiki/Periodic_point">periodic
point</a> theory, so you decide to give it a try too.</p>

<h2>Definitions</h2>

<dl>

<dt><dfn>fixed point</dfn></dt><dt> </dt><dd>(of a function <samp>f</samp>) A
point <samp>x</samp> such that <samp>f x = x</samp>. In this
description we are using OCaml notation, in which functions always
have one argument and parentheses are not needed around
arguments.</dd>

<dt><dfn>computed fixed point</dfn></dt> <dd>(of a
function <samp>f</samp> with respect to an initial
point <samp>x</samp>) A fixed point of <samp>f</samp> computed by
calculating <samp>x</samp>, <samp>f x</samp>, <samp>f (f
x)</samp>, <samp>f (f (f x))</samp>, etc., stopping when a fixed point
is found for <samp>f</samp>. If no fixed point is ever found by this
procedure, the computed fixed point is not defined for <samp>f</samp>
and <samp>x</samp>.</dd>

<dt><dfn>periodic point</dfn></dt><dt> </dt><dd> (of a function <samp>f</samp>
with period <samp>p</samp>) A point <samp>x</samp> such that <samp>f
(f ... (f x)) = x</samp>, where there are <samp>p</samp> occurrences
of <samp>f</samp> in the call.  That is, a periodic point is like a
fixed point, except the function returns to the point
after <samp>p</samp> iterations instead of 1 iteration. Every point is
a periodic point for <samp>p</samp>=0. A fixed point is a periodic
point for <samp>p</samp>=1.</dd>

<dt><dfn>computed periodic point</dfn></dt> <dd>(of a
function <samp>f</samp> with respect to a period <samp>p</samp> and an
initial point <samp>x</samp>) A periodic point of <samp>f</samp> with
period <samp>p</samp>, computed by calculating <samp>x</samp>, <samp>f
x</samp>, <samp>f (f x)</samp>, <samp>f (f (f x))</samp>, etc.,
stopping when a periodic point with period <samp>p</samp> is found
for <samp>f</samp>. The computed periodic point need not be equal
to <samp>x</samp>. If no periodic point is ever found by this
procedure, the computed periodic point is not defined
for <samp>f</samp>, <samp>p</samp>, and <samp>x</samp>.</dd>

<dt><dfn>symbol</dfn></dt> <dd>A symbol used in a grammar. It can be either a
nonterminal symbol or a terminal symbol; each kind of symbol has a
value, whose type is arbitrary. A symbol has the following OCaml type:

<pre><samp>type ('nonterminal, 'terminal) symbol =
  | N of 'nonterminal
  | T of 'terminal
</samp></pre>
</dd>

<dt><dfn>right hand side</dfn></dt> <dd>A list of symbols. It
corresponds to the right hand side of a single grammar rule. A right
hand side can be empty.</dd>

<dt><dfn>rule</dfn></dt> <dd>A pair, consisting of (1) a nonterminal value
(the left hand side of the grammar rule) and (2) a right hand side.</dd>

<dt><dfn>grammar</dfn></dt> <dd>A pair, consisting of a start symbol and a
list of rules. The start symbol is a nonterminal value.</dd>

</dl>

<h2>Assignment</h2>

<p>You will warm up by modeling sets using OCaml lists. The empty list
represents the empty set, and if the list <samp>t</samp> represents
the set T, then the list <samp>h::t</samp> represents the set
{<samp>h</samp>}∪T. Although sets by definition do not contain
duplicates, the lists that represent sets can contain duplicates.
Another set of warmup exercises will compute fixed and periodic points.
Finally, you can write a function that filters blind alleys.
</p>

<ol>
  <li>
Write a function <samp>subset a b</samp> that returns true iff
<em>a</em>⊆<em>b</em>, i.e., if the
set represented by the list <samp>a</samp> is a subset of the set
represented by the list <samp>b</samp>. Every set is a subset of itself.
This function should be generic to lists of any type: that is, the type
of <samp>subset</samp> should be a generalization of <samp>'a list
-&gt; 'a list -&gt; bool</samp>.
</li>

<li>Write a function <samp>equal_sets a b</samp>
that returns true iff the represented sets are equal.
</li>

<li>Write a function <samp>set_union a b</samp> that returns
a list representing a∪b.
</li>

<li>Write a function <samp>set_intersection a b</samp> that returns a
list representing a∩b.
</li>

<li>Write a function <samp>set_diff a b</samp> that returns a list representing
<em>a</em>−<em>b</em>, that is, the set of all members of
<em>a</em> that are not also members of <em>b</em>.</li>

<li>Write a
function <samp>computed_fixed_point eq f x</samp> that returns the
computed fixed point for <samp>f</samp> with respect
to <samp>x</samp>, assuming that <samp>eq</samp> is the equality
predicate for <samp>f</samp>'s domain. A common case is that
<samp>eq</samp> will be <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VAL%28=%29"><samp>(=)</samp></a>, that is, the builtin
equality predicate of OCaml; but any predicate can be used. If there
is no computed fixed point, your implementation can do whatever it
wants: for example, it can print a diagnostic, or go into a loop, or
send nasty email messages to the user's relatives.</li>

<li>Write a function
<samp>computed_periodic_point eq f p x</samp> that returns the
computed periodic point for <samp>f</samp> with period <samp>p</samp>
and with respect to <samp>x</samp>, assuming that <samp>eq</samp> is
the equality predicate for <samp>f</samp>'s domain.</li>

<li>Write a function <samp>while_away s p x</samp> that returns the
longest list [x; s x; s (s x); ...] such that <samp>p e</samp> is true
for every element <samp>e</samp> in the list. That is, if <samp>p
x</samp> is false, return <samp>[]</samp>; otherwise if <samp>p (s
x)</samp> is false, return <samp>[x]</samp>; otherwise if <samp>p (s
(s x))</samp> is false, return <samp>[x; s x]</samp>; and so
forth. For example, <samp>while_away ((+) 3) ((&gt;) 10) 0</samp>
returns [0; 3; 6; 9]. Your implementation can assume that
<samp>p</samp> eventually returns <samp>false</samp>.</li>

<li>Write a function <samp>rle_decode lp</samp> that decodes a list of
pairs <samp>lp</samp>
in <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length
encoding</a> form. The first element of each pair is a nonnegative
integer specifying the repetition length; the second element is the
value to repeat. For example, <samp>rle_decode [2,0; 1,6]</samp> should
return [0; 0; 6] and <samp>rle_decode [3,"w"; 1,"x"; 0,"y";
2,"z"]</samp> should return ["w"; "w"; "w"; "x"; "z"; "z"].</li>

<li>OK, now for the real work. Write a function <samp>filter_blind_alleys
g</samp> that returns a copy of the grammar <samp>g</samp> with all
blind-alley rules removed. This
function should preserve the order of rules: that is, all rules that
are returned should be in the same order as the rules
in <samp>g</samp>.</li>

<li>Supply at least one test case for each of the above functions in
the style shown in the sample test cases below. When testing the
function <samp>F</samp> call the test
cases <samp>my_F_test0</samp>, <samp>my_F_test1</samp>, etc. For
example, for
<samp>subset</samp> your first test case should be
called <samp>my_subset_test0</samp>. Your test cases should exercise
all the above functions, even though the sample test cases do
not.</li>

</ol>

<p>Your code should follow these guidelines:</p>

<ol>
  <li>
Your code may use
the <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html"><samp>Pervasives</samp></a>
and <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html"><samp>List</samp></a>
modules, but it should use no other modules other than your own
code.</li>

<li>It is OK (and indeed encouraged) for your solutions to be based
on one another; for example, it is fine
for <samp>filter_blind_alleys</samp> to use <samp>equal_sets</samp>
and <samp>computed_fixed_point</samp>.</li>

<li>Your code should prefer pattern matching to conditionals when
pattern matching is natural.</li>

<li>Your code should be free
of <a href="https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29">side
effects</a> such as loops, assignment, input/output, <samp>incr</samp>,
and <samp>decr</samp>. Use recursion instead of loops.</li>

<li>Simplicity is more important than efficiency, but your code should
avoid using unnecessary time and space when it is easy to do so. For
example, instead of repeating a expression, compute its value once and
reuse the computed value.</li>

<li>The test cases below should work with your program. You are unlikely
to get credit for it otherwise.</li>

</ol>

<h2>Submit</h2>

<p>Submit two files. The file <samp>hw1.ml</samp>
should implement the abovementioned functions, along with any
auxiliary types and functions; in particular, it should define
the <samp>symbol</samp> type as shown above. The
file <samp>hw1test.ml</samp> should contain your test cases. Please do not
put your name, student ID, or other personally identifying information
in your files.</p>

<h2>Sample test cases</h2>

<p>See <a href="http://web.cs.ucla.edu/classes/winter18/cs131/hw/hw1sample.ml">hw1sample.ml</a> for a copy of these tests.</p>

<pre><samp>let subset_test0 = subset [] [1;2;3]
let subset_test1 = subset [3;1;3] [1;2;3]
let subset_test2 = <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALnot">not</a> (subset [1;3;7] [4;1;3])

let equal_sets_test0 = equal_sets [1;3] [3;1;3]
let equal_sets_test1 = not (equal_sets [1;3;4] [3;1;3])

let set_union_test0 = equal_sets (set_union [] [1;2;3]) [1;2;3]
let set_union_test1 = equal_sets (set_union [3;1;3] [1;2;3]) [1;2;3]
let set_union_test2 = equal_sets (set_union [] []) []

let set_intersection_test0 =
  equal_sets (set_intersection [] [1;2;3]) []
let set_intersection_test1 =
  equal_sets (set_intersection [3;1;3] [1;2;3]) [1;3]
let set_intersection_test2 =
  equal_sets (set_intersection [1;2;3;4] [3;1;2;4]) [4;3;2;1]

let set_diff_test0 = equal_sets (set_diff [1;3] [1;4;3;1]) []
let set_diff_test1 = equal_sets (set_diff [4;3;1;1;3] [1;3]) [4]
let set_diff_test2 = equal_sets (set_diff [4;3;1] []) [1;3;4]
let set_diff_test3 = equal_sets (set_diff [] [4;3;1]) []

let computed_fixed_point_test0 =
  computed_fixed_point (=) (fun x -&gt; x <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VAL%28/%29">/</a> 2) 1000000000 = 0
let computed_fixed_point_test1 =
  computed_fixed_point (=) (fun x -&gt; x <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VAL%28%20*.%20%29">*.</a> 2.) 1. = <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinfinity">infinity</a>
let computed_fixed_point_test2 =
  computed_fixed_point (=) <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALsqrt">sqrt</a> 10. = 1.
let computed_fixed_point_test3 =
  ((computed_fixed_point (fun x y -&gt; <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALabs_float">abs_float</a> (x <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VAL%28-.%29">-.</a> y) &lt; 1.)
			 (fun x -&gt; x <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VAL%28/.%29">/.</a> 2.)
			 10.)
   = 1.25)

let computed_periodic_point_test0 =
  computed_periodic_point (=) (fun x -&gt; x / 2) 0 (-1) = -1
let computed_periodic_point_test1 =
  computed_periodic_point (=) (fun x -&gt; x *. x -. 1.) 2 0.5 = -1.

(* An example grammar for a small subset of Awk.  *)

type awksub_nonterminals =
  | Expr | Lvalue | Incrop | Binop | Num

let awksub_rules =
   [Expr, [T"("; N Expr; T")"];
    Expr, [N Num];
    Expr, [N Expr; N Binop; N Expr];
    Expr, [N Lvalue];
    Expr, [N Incrop; N Lvalue];
    Expr, [N Lvalue; N Incrop];
    Lvalue, [T"$"; N Expr];
    Incrop, [T"++"];
    Incrop, [T"--"];
    Binop, [T"+"];
    Binop, [T"-"];
    Num, [T"0"];
    Num, [T"1"];
    Num, [T"2"];
    Num, [T"3"];
    Num, [T"4"];
    Num, [T"5"];
    Num, [T"6"];
    Num, [T"7"];
    Num, [T"8"];
    Num, [T"9"]]

let awksub_grammar = Expr, awksub_rules

let awksub_test0 =
  filter_blind_alleys awksub_grammar = awksub_grammar

let awksub_test1 =
  filter_blind_alleys (Expr, <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html#VALtl">List.tl</a> awksub_rules) = (Expr, List.tl awksub_rules)

let awksub_test2 =
  filter_blind_alleys (Expr,
      [Expr, [N Num];
       Expr, [N Lvalue];
       Expr, [N Expr; N Lvalue];
       Expr, [N Lvalue; N Expr];
       Expr, [N Expr; N Binop; N Expr];
       Lvalue, [N Lvalue; N Expr];
       Lvalue, [N Expr; N Lvalue];
       Lvalue, [N Incrop; N Lvalue];
       Lvalue, [N Lvalue; N Incrop];
       Incrop, [T"++"]; Incrop, [T"--"];
       Binop, [T"+"]; Binop, [T"-"];
       Num, [T"0"]; Num, [T"1"]; Num, [T"2"]; Num, [T"3"]; Num, [T"4"];
       Num, [T"5"]; Num, [T"6"]; Num, [T"7"]; Num, [T"8"]; Num, [T"9"]])
  = (Expr,
     [Expr, [N Num];
      Expr, [N Expr; N Binop; N Expr];
      Incrop, [T"++"]; Incrop, [T"--"];
      Binop, [T "+"]; Binop, [T "-"];
      Num, [T "0"]; Num, [T "1"]; Num, [T "2"]; Num, [T "3"]; Num, [T "4"];
      Num, [T "5"]; Num, [T "6"]; Num, [T "7"]; Num, [T "8"]; Num, [T "9"]])

let awksub_test3 =
  filter_blind_alleys (Expr, List.tl (List.tl (List.tl awksub_rules))) =
    filter_blind_alleys (Expr, List.tl (List.tl awksub_rules))

type giant_nonterminals =
  | Conversation | Sentence | Grunt | Snore | Shout | Quiet

let giant_grammar =
  Conversation,
  [Snore, [T"ZZZ"];
   Quiet, [];
   Grunt, [T"khrgh"];
   Shout, [T"aooogah!"];
   Sentence, [N Quiet];
   Sentence, [N Grunt];
   Sentence, [N Shout];
   Conversation, [N Snore];
   Conversation, [N Sentence; T","; N Conversation]]

let giant_test0 =
  filter_blind_alleys giant_grammar = giant_grammar

let giant_test1 =
  filter_blind_alleys (Sentence, List.tl (<a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALsnd">snd</a> giant_grammar)) =
    (Sentence,
     [Quiet, []; Grunt, [T "khrgh"]; Shout, [T "aooogah!"];
      Sentence, [N Quiet]; Sentence, [N Grunt]; Sentence, [N Shout]])

let giant_test2 =
  filter_blind_alleys (Sentence, List.tl (List.tl (snd giant_grammar))) =
    (Sentence,
     [Grunt, [T "khrgh"]; Shout, [T "aooogah!"];
      Sentence, [N Grunt]; Sentence, [N Shout]])
</samp></pre>

<h2>Sample use of test cases</h2>

<p>When testing on SEASnet, use one of the machines
<samp>lnxsrv06.seas.ucla.edu</samp>,
<samp>lnxsrv07.seas.ucla.edu</samp>, and
<samp>lnxsrv09.seas.ucla.edu</samp>. Make
sure <samp>/usr/local/cs/bin</samp> is at the start of your path, so
that you get the proper version of OCaml.  To do this, append the
following lines to your <samp>$HOME/.profile</samp> file if you
use <a href="https://www.gnu.org/software/bash/"><samp>bash</samp></a>
or <a href="http://www.kornshell.com/"><samp>ksh</samp></a>:</p>

<pre><samp>export PATH=/usr/local/cs/bin:$PATH
</samp></pre>

<p>or the following line to your <samp>$HOME/.login</samp> file if you use
<a href="https://en.wikipedia.org/wiki/Tcsh"><samp>tcsh</samp></a> or
<a href="https://en.wikipedia.org/wiki/C_shell">csh</a>:</p>

<pre><samp>set path=(/usr/local/cs/bin $path)
</samp></pre>

<p>The command <samp>ocaml</samp> should output the version number 4.04.2.</p>

<p>If you put the <a href="http://web.cs.ucla.edu/classes/winter18/cs131/hw/hw1sample.ml">sample test cases</a> into a file
<samp>hw1sample.ml</samp>, you should be able to use it as follows to
test your <samp>hw1.ml</samp> solution on the SEASnet implementation
of OCaml. Similarly, the command <samp>#use "hw1test.ml";;</samp>
should run your own test cases on your solution.</p>

<pre><samp>$ ocaml
        OCaml version 4.04.2

# #use "hw1.ml";;
type ('a, 'b) symbol = N of 'a | T of 'b
...
# #use "<a href="http://web.cs.ucla.edu/classes/winter18/cs131/hw/hw1sample.ml">hw1sample.ml</a>";;
val subset_test0 : bool = true
val subset_test1 : bool = true
val subset_test2 : bool = true
val equal_sets_test0 : bool = true
val equal_sets_test1 : bool = true
val set_union_test0 : bool = true
val set_union_test1 : bool = true
val set_union_test2 : bool = true
val set_intersection_test0 : bool = true
val set_intersection_test1 : bool = true
val set_intersection_test2 : bool = true
val computed_fixed_point_test0 : bool = true
val computed_fixed_point_test1 : bool = true
val computed_fixed_point_test2 : bool = true
val computed_fixed_point_test3 : bool = true
val computed_periodic_point_test0 : bool = true
val computed_periodic_point_test1 : bool = true
type awksub_nonterminals = Expr | Lvalue | Incrop | Binop | Num
val awksub_rules :
  (awksub_nonterminals * (awksub_nonterminals, string) symbol list) list =
  [(Expr, [T "("; N Expr; T ")"]); (Expr, [N Num]);
   (Expr, [N Expr; N Binop; N Expr]); (Expr, [N Lvalue]);
   (Expr, [N Incrop; N Lvalue]); (Expr, [N Lvalue; N Incrop]);
   (Lvalue, [T "$"; N Expr]); (Incrop, [T "++"]); (Incrop, [T "--"]);
   (Binop, [T "+"]); (Binop, [T "-"]); (Num, [T "0"]); (Num, [T "1"]);
   (Num, [T "2"]); (Num, [T "3"]); (Num, [T "4"]); (Num, [T "5"]);
   (Num, [T "6"]); (Num, [T "7"]); (Num, [T "8"]); (Num, [T "9"])]
val awksub_grammar :
  awksub_nonterminals *
  (awksub_nonterminals * (awksub_nonterminals, string) symbol list) list =
  (Expr,
   [(Expr, [T "("; N Expr; T ")"]); (Expr, [N Num]);
    (Expr, [N Expr; N Binop; N Expr]); (Expr, [N Lvalue]);
    (Expr, [N Incrop; N Lvalue]); (Expr, [N Lvalue; N Incrop]);
    (Lvalue, [T "$"; N Expr]); (Incrop, [T "++"]); (Incrop, [T "--"]);
    (Binop, [T "+"]); (Binop, [T "-"]); (Num, [T "0"]); (Num, [T "1"]);
    (Num, [T "2"]); (Num, [T "3"]); (Num, [T "4"]); (Num, [T "5"]);
    (Num, [T "6"]); (Num, [T "7"]); (Num, [T "8"]); (Num, [T "9"])])
val awksub_test0 : bool = true
val awksub_test1 : bool = true
val awksub_test2 : bool = true
val awksub_test3 : bool = true
type giant_nonterminals =
    Conversation
  | Sentence
  | Grunt
  | Snore
  | Shout
  | Quiet
val giant_grammar :
  giant_nonterminals *
  (giant_nonterminals * (giant_nonterminals, string) symbol list) list =
  (Conversation,
   [(Snore, [T "ZZZ"]); (Quiet, []); (Grunt, [T "khrgh"]);
    (Shout, [T "aooogah!"]); (Sentence, [N Quiet]); (Sentence, [N Grunt]);
    (Sentence, [N Shout]); (Conversation, [N Snore]);
    (Conversation, [N Sentence; T ","; N Conversation])])
val giant_test0 : bool = true
val giant_test1 : bool = true
val giant_test2 : bool = true
#
</samp></pre>

<hr>
<address>
 © 2006–2011, 2013–2017
 <a href="http://web.cs.ucla.edu/classes/winter18/cs131/mail-eggert.html">Paul Eggert</a>.
 See <a href="http://web.cs.ucla.edu/classes/winter18/cs131/copyright.html">copying rules</a>.<br>

 $Id: hw1.html,v 1.73 2017/10/02 18:36:32 eggert Exp $

</address>



</body></html>